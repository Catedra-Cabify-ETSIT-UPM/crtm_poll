{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"crtm_poll Python scripts for polling different data from CRTM. docker Features CRTM intercity buses: Get the stop times for all the bus lines in a given stop. Get the stop times for all the bus lines for every given stop code in a file. Get the parsed stop times for all the bus lines for every given stop code in a file in CSV format. Run a periodic daemon that executes one of the possible functions and stores the output a given file. Perform a test to find out the optimal number of parallel connections when polling the server. Installation pip3 install git+git://github.com/cgupm/crtm_poll Docker You can use the Dockerfile to build a minimal image containing this tool and its dependencies or directly use the public image : docker run -it --rm -v \" ${ PWD } :/home/user\" -v /etc/localtime:/etc/localtime:ro --user $( id -u ) : $( id -g ) cgupm/crtm_poll Usage Once installed, this package provides a command line script that can be run as follows: crtm_poll --help crtm_poll gst 8_17491 Testing Tests can be run executing pytest or make test within the project's directory. License GPLv3 Author Information cgupm: c.garcia-maurino (at) alumnos.upm.es","title":"Overview"},{"location":"#crtm_poll","text":"Python scripts for polling different data from CRTM. docker","title":"crtm_poll"},{"location":"#features","text":"CRTM intercity buses: Get the stop times for all the bus lines in a given stop. Get the stop times for all the bus lines for every given stop code in a file. Get the parsed stop times for all the bus lines for every given stop code in a file in CSV format. Run a periodic daemon that executes one of the possible functions and stores the output a given file. Perform a test to find out the optimal number of parallel connections when polling the server.","title":"Features"},{"location":"#installation","text":"pip3 install git+git://github.com/cgupm/crtm_poll","title":"Installation"},{"location":"#docker","text":"You can use the Dockerfile to build a minimal image containing this tool and its dependencies or directly use the public image : docker run -it --rm -v \" ${ PWD } :/home/user\" -v /etc/localtime:/etc/localtime:ro --user $( id -u ) : $( id -g ) cgupm/crtm_poll","title":"Docker"},{"location":"#usage","text":"Once installed, this package provides a command line script that can be run as follows: crtm_poll --help crtm_poll gst 8_17491","title":"Usage"},{"location":"#testing","text":"Tests can be run executing pytest or make test within the project's directory.","title":"Testing"},{"location":"#license","text":"GPLv3","title":"License"},{"location":"#author-information","text":"cgupm: c.garcia-maurino (at) alumnos.upm.es","title":"Author Information"},{"location":"reference/cli/","text":"Console script for crtm_poll. load_stops_file ( stops_file ) Read file with stop codes (one by line) to array. Parameters: Name Type Description Default stops_file str Path to the file containing the stop codes (one by line) required Returns: Type Description list List of stop codes Source code in crtm_poll/cli.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def load_stops_file ( stops_file ): \"\"\"Read file with stop codes (one by line) to array. Arguments: stops_file (str): Path to the file containing the stop codes (one by line) Returns: list: List of stop codes \"\"\" logger . debug ( \"stops_file: \" + str ( stops_file )) cod_stops = [] with open ( stops_file ) as f : for line in f : cod_stops . append ( line . rstrip ( ' \\n ' )) logger . debug ( \"cod_stops: \" + str ( cod_stops )) random . shuffle ( cod_stops ) return cod_stops","title":"cli.py"},{"location":"reference/cli/#crtm_poll.cli","text":"Console script for crtm_poll.","title":"crtm_poll.cli"},{"location":"reference/cli/#crtm_poll.cli.load_stops_file","text":"Read file with stop codes (one by line) to array. Parameters: Name Type Description Default stops_file str Path to the file containing the stop codes (one by line) required Returns: Type Description list List of stop codes Source code in crtm_poll/cli.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def load_stops_file ( stops_file ): \"\"\"Read file with stop codes (one by line) to array. Arguments: stops_file (str): Path to the file containing the stop codes (one by line) Returns: list: List of stop codes \"\"\" logger . debug ( \"stops_file: \" + str ( stops_file )) cod_stops = [] with open ( stops_file ) as f : for line in f : cod_stops . append ( line . rstrip ( ' \\n ' )) logger . debug ( \"cod_stops: \" + str ( cod_stops )) random . shuffle ( cod_stops ) return cod_stops","title":"load_stops_file()"},{"location":"reference/crtm_api/stop_times/","text":"fetch ( cod_stop , session , fetch_conf ) Fetch the stops waiting time for a given stop reusing a session. Passes some additional data to the fetch_log function. The CSV column names are: 'actual_date, cod_stop, resp_time, resp_status, resp_length, timeout, connection_error, max_connections, timeout_time' Parameters: Name Type Description Default cod_stop str The stop code in CRTM's format (e.g. 8_17491). required session object The aiohttp ClientSession. required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description str Response text. Source code in crtm_poll/crtm_api/stop_times.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 async def fetch ( cod_stop , session , fetch_conf ): \"\"\"Fetch the stops waiting time for a given stop reusing a session. Passes some additional data to the fetch_log function. The CSV column names are: 'actual_date, cod_stop, resp_time, resp_status, resp_length, timeout, connection_error, max_connections, timeout_time' Arguments: cod_stop (str): The stop code in CRTM's format (e.g. 8_17491). session (object): The aiohttp ClientSession. fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: str: Response text. \"\"\" global counter actual_time = None resp_time = None resp_status = None resp_length = None timeout = None connection_error = None url = 'https://www.crtm.es/widgets/api/GetStopsTimes.php' params = { 'codStop' : cod_stop , 'type' : 1 , 'orderBy' : 2 , 'stopTimesByIti' : 3 } actual_time = datetime . datetime . now () try : async with session . get ( url , params = params ) as response : dt_2 = datetime . datetime . now () resp_time = ( dt_2 - actual_time ) . total_seconds () resp_status = response . status resp_text = await response . text () resp_length = len ( resp_text ) timeout = False connection_error = False logger . info ( \"Response time: \" + str ( resp_time ) + \" code: \" + str ( resp_status ) + \" length: \" + str ( resp_length )) fetch_log ( fetch_conf [ 'log' ], actual_time , cod_stop , resp_time , resp_status , resp_length , timeout , connection_error , fetch_conf [ 'max_connections' ], fetch_conf [ 'timeout' ]) return resp_text except asyncio . TimeoutError : dt_2 = datetime . datetime . now () resp_time = ( dt_2 - actual_time ) . total_seconds () timeout = True connection_error = False logger . warning ( \"Timeout\" ) fetch_log ( fetch_conf [ 'log' ], actual_time , cod_stop , resp_time , resp_status , resp_length , timeout , connection_error , fetch_conf [ 'max_connections' ], fetch_conf [ 'timeout' ]) except client_exceptions . ClientConnectorError : dt_2 = datetime . datetime . now () resp_time = ( dt_2 - actual_time ) . total_seconds () timeout = False connection_error = True logger . warning ( \"Connection error\" ) fetch_log ( fetch_conf [ 'log' ], actual_time , cod_stop , resp_time , resp_status , resp_length , timeout , connection_error , fetch_conf [ 'max_connections' ], fetch_conf [ 'timeout' ]) fetch_log ( fetch_log = None , * args ) Write the passed arguments as CSV to fetch_log if set. Parameters: Name Type Description Default fetch_log str Path to the fethc log file. None *args object CSV line column values. () Source code in crtm_poll/crtm_api/stop_times.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def fetch_log ( fetch_log = None , * args ): \"\"\"Write the passed arguments as CSV to fetch_log if set. Arguments: fetch_log (str): Path to the fethc log file. *args (object): CSV line column values. \"\"\" if ( fetch_log ): csv_columns = 'actual_date,cod_stop,resp_time,resp_status,' \\ 'resp_length,timeout,connection_error,' \\ 'max_connections,timeout_time' log_csv = \",\" . join ([ str ( arg ) for arg in args ]) logger . debug ( \"CSV fetch log line: \" + log_csv ) with FileLock ( fetch_log + '.lock' , timeout = 10 ): path_exists = pathlib . Path ( fetch_log ) . exists () with open ( fetch_log , 'a+' ) as f : if ( path_exists ): f . write ( ' \\n ' ) else : f . write ( csv_columns + ' \\n ' ) f . write ( log_csv ) get_stop_times ( cod_stop , fetch_conf ) Get the stop times for all the bus lines in a given stop. Parameters: Name Type Description Default cod_stop str The stop code in CRTM's format (e.g. 8_17491). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description list API answer in JSON format. float: Request time in seconds. Source code in crtm_poll/crtm_api/stop_times.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def get_stop_times ( cod_stop , fetch_conf ): \"\"\"Get the stop times for all the bus lines in a given stop. Arguments: cod_stop (str): The stop code in CRTM's format (e.g. 8_17491). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: list: API answer in JSON format. float: Request time in seconds. \"\"\" json_array , total_time = get_stop_times_batch ([ cod_stop ], fetch_conf ) try : json = json_array [ 0 ] time = total_time return json , time except IndexError : logger . error ( \"Empty answer\" ) sys . exit ( 1 ) get_stop_times_batch ( cod_stops , fetch_conf ) Get the stop times for all the bus lines for the given stops. Parameters: Name Type Description Default cod_stops list List of stop codes in CRTM's format (e.g. 8_17491). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description list API answers in JSON format. float: Total spent time in seconds. Source code in crtm_poll/crtm_api/stop_times.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def get_stop_times_batch ( cod_stops , fetch_conf ): \"\"\"Get the stop times for all the bus lines for the given stops. Arguments: cod_stops (list): List of stop codes in CRTM's format (e.g. 8_17491). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: list: API answers in JSON format. float: Total spent time in seconds. \"\"\" dt_1 = datetime . datetime . now () loop = asyncio . get_event_loop () future = asyncio . ensure_future ( run ( cod_stops , fetch_conf )) loop . run_until_complete ( future ) dt_2 = datetime . datetime . now () json_array = list ( filter ( None , future . result ())) total_time = ( dt_2 - dt_1 ) . total_seconds () return json_array , total_time get_stop_times_batch_parsed ( cod_stops , fetch_conf ) Get the stop times for all the bus lines for the given stops parsing the JSON answer to CSV. The CSV column names are: 'actual_date,cod_stop,cod_line,cod_issue,eta,destination_stop' Parameters: Name Type Description Default cod_stops list List of stop codes in CRTM's format (e.g. 8_17491). required Returns: Type Description list Parsed API answers in CSV format. float: Total spent time in seconds. Source code in crtm_poll/crtm_api/stop_times.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def get_stop_times_batch_parsed ( cod_stops , fetch_conf ): \"\"\"Get the stop times for all the bus lines for the given stops parsing the JSON answer to CSV. The CSV column names are: 'actual_date,cod_stop,cod_line,cod_issue,eta,destination_stop' Arguments: cod_stops (list): List of stop codes in CRTM's format (e.g. 8_17491). Returns: list: Parsed API answers in CSV format. float: Total spent time in seconds. \"\"\" json_array , total_time = get_stop_times_batch ( cod_stops , fetch_conf ) csv_array = [] for stop in json_array : try : split_stop = stop . split ( '{' , 1 ) except AttributeError : logger . warning ( \"Empty answer\" ) continue if ( len ( split_stop ) > 1 ): stop = '{' + split_stop [ 1 ] try : stop_json = json . loads ( stop ) except ValueError : logger . warning ( \"json error\" ) continue try : times = stop_json [ 'stopTimes' ][ 'times' ][ 'Time' ] for time in times : selected_fields = [ stop_json [ 'stopTimes' ][ 'actualDate' ], stop_json [ 'stopTimes' ][ 'stop' ][ 'codStop' ], time [ 'line' ][ 'codLine' ], time [ 'codIssue' ], time [ 'time' ], time [ 'destinationStop' ][ 'codStop' ], ] row = ',' . join ( selected_fields ) csv_array . append ( row ) except ( KeyError , TypeError ): logger . warning ( \"Answer without times\" ) continue except Exception as e : logger . warning ( \"Unknown error: \" + str ( e )) continue return csv_array , total_time run ( cod_stops , fetch_conf ) Async function that generates a aiohttp ClientSession and fetches the given stops. Parameters: Name Type Description Default cod_stops list List of stop codes in CRTM's format (e.g. 8_17491). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description list The responses. Source code in crtm_poll/crtm_api/stop_times.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 async def run ( cod_stops , fetch_conf ): \"\"\"Async function that generates a aiohttp ClientSession and fetches the given stops. Arguments: cod_stops (list): List of stop codes in CRTM's format (e.g. 8_17491). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: list: The responses. \"\"\" tasks = [] # Fetch all responses within one Client session, # keep connection alive for all requests. connector = TCPConnector ( limit = fetch_conf [ 'max_connections' ]) timeout = ClientTimeout ( total = fetch_conf [ 'timeout' ]) async with ClientSession ( connector = connector , timeout = timeout ) as session : for cod_stop in cod_stops : task = asyncio . ensure_future ( fetch ( cod_stop , session , fetch_conf )) tasks . append ( task ) responses = await asyncio . gather ( * tasks ) # you now have all response bodies in this variable return responses","title":"stop_times.py"},{"location":"reference/crtm_api/stop_times/#crtm_poll.crtm_api.stop_times","text":"","title":"crtm_poll.crtm_api.stop_times"},{"location":"reference/crtm_api/stop_times/#crtm_poll.crtm_api.stop_times.fetch","text":"Fetch the stops waiting time for a given stop reusing a session. Passes some additional data to the fetch_log function. The CSV column names are: 'actual_date, cod_stop, resp_time, resp_status, resp_length, timeout, connection_error, max_connections, timeout_time' Parameters: Name Type Description Default cod_stop str The stop code in CRTM's format (e.g. 8_17491). required session object The aiohttp ClientSession. required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description str Response text. Source code in crtm_poll/crtm_api/stop_times.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 async def fetch ( cod_stop , session , fetch_conf ): \"\"\"Fetch the stops waiting time for a given stop reusing a session. Passes some additional data to the fetch_log function. The CSV column names are: 'actual_date, cod_stop, resp_time, resp_status, resp_length, timeout, connection_error, max_connections, timeout_time' Arguments: cod_stop (str): The stop code in CRTM's format (e.g. 8_17491). session (object): The aiohttp ClientSession. fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: str: Response text. \"\"\" global counter actual_time = None resp_time = None resp_status = None resp_length = None timeout = None connection_error = None url = 'https://www.crtm.es/widgets/api/GetStopsTimes.php' params = { 'codStop' : cod_stop , 'type' : 1 , 'orderBy' : 2 , 'stopTimesByIti' : 3 } actual_time = datetime . datetime . now () try : async with session . get ( url , params = params ) as response : dt_2 = datetime . datetime . now () resp_time = ( dt_2 - actual_time ) . total_seconds () resp_status = response . status resp_text = await response . text () resp_length = len ( resp_text ) timeout = False connection_error = False logger . info ( \"Response time: \" + str ( resp_time ) + \" code: \" + str ( resp_status ) + \" length: \" + str ( resp_length )) fetch_log ( fetch_conf [ 'log' ], actual_time , cod_stop , resp_time , resp_status , resp_length , timeout , connection_error , fetch_conf [ 'max_connections' ], fetch_conf [ 'timeout' ]) return resp_text except asyncio . TimeoutError : dt_2 = datetime . datetime . now () resp_time = ( dt_2 - actual_time ) . total_seconds () timeout = True connection_error = False logger . warning ( \"Timeout\" ) fetch_log ( fetch_conf [ 'log' ], actual_time , cod_stop , resp_time , resp_status , resp_length , timeout , connection_error , fetch_conf [ 'max_connections' ], fetch_conf [ 'timeout' ]) except client_exceptions . ClientConnectorError : dt_2 = datetime . datetime . now () resp_time = ( dt_2 - actual_time ) . total_seconds () timeout = False connection_error = True logger . warning ( \"Connection error\" ) fetch_log ( fetch_conf [ 'log' ], actual_time , cod_stop , resp_time , resp_status , resp_length , timeout , connection_error , fetch_conf [ 'max_connections' ], fetch_conf [ 'timeout' ])","title":"fetch()"},{"location":"reference/crtm_api/stop_times/#crtm_poll.crtm_api.stop_times.fetch_log","text":"Write the passed arguments as CSV to fetch_log if set. Parameters: Name Type Description Default fetch_log str Path to the fethc log file. None *args object CSV line column values. () Source code in crtm_poll/crtm_api/stop_times.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def fetch_log ( fetch_log = None , * args ): \"\"\"Write the passed arguments as CSV to fetch_log if set. Arguments: fetch_log (str): Path to the fethc log file. *args (object): CSV line column values. \"\"\" if ( fetch_log ): csv_columns = 'actual_date,cod_stop,resp_time,resp_status,' \\ 'resp_length,timeout,connection_error,' \\ 'max_connections,timeout_time' log_csv = \",\" . join ([ str ( arg ) for arg in args ]) logger . debug ( \"CSV fetch log line: \" + log_csv ) with FileLock ( fetch_log + '.lock' , timeout = 10 ): path_exists = pathlib . Path ( fetch_log ) . exists () with open ( fetch_log , 'a+' ) as f : if ( path_exists ): f . write ( ' \\n ' ) else : f . write ( csv_columns + ' \\n ' ) f . write ( log_csv )","title":"fetch_log()"},{"location":"reference/crtm_api/stop_times/#crtm_poll.crtm_api.stop_times.get_stop_times","text":"Get the stop times for all the bus lines in a given stop. Parameters: Name Type Description Default cod_stop str The stop code in CRTM's format (e.g. 8_17491). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description list API answer in JSON format. float: Request time in seconds. Source code in crtm_poll/crtm_api/stop_times.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def get_stop_times ( cod_stop , fetch_conf ): \"\"\"Get the stop times for all the bus lines in a given stop. Arguments: cod_stop (str): The stop code in CRTM's format (e.g. 8_17491). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: list: API answer in JSON format. float: Request time in seconds. \"\"\" json_array , total_time = get_stop_times_batch ([ cod_stop ], fetch_conf ) try : json = json_array [ 0 ] time = total_time return json , time except IndexError : logger . error ( \"Empty answer\" ) sys . exit ( 1 )","title":"get_stop_times()"},{"location":"reference/crtm_api/stop_times/#crtm_poll.crtm_api.stop_times.get_stop_times_batch","text":"Get the stop times for all the bus lines for the given stops. Parameters: Name Type Description Default cod_stops list List of stop codes in CRTM's format (e.g. 8_17491). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description list API answers in JSON format. float: Total spent time in seconds. Source code in crtm_poll/crtm_api/stop_times.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def get_stop_times_batch ( cod_stops , fetch_conf ): \"\"\"Get the stop times for all the bus lines for the given stops. Arguments: cod_stops (list): List of stop codes in CRTM's format (e.g. 8_17491). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: list: API answers in JSON format. float: Total spent time in seconds. \"\"\" dt_1 = datetime . datetime . now () loop = asyncio . get_event_loop () future = asyncio . ensure_future ( run ( cod_stops , fetch_conf )) loop . run_until_complete ( future ) dt_2 = datetime . datetime . now () json_array = list ( filter ( None , future . result ())) total_time = ( dt_2 - dt_1 ) . total_seconds () return json_array , total_time","title":"get_stop_times_batch()"},{"location":"reference/crtm_api/stop_times/#crtm_poll.crtm_api.stop_times.get_stop_times_batch_parsed","text":"Get the stop times for all the bus lines for the given stops parsing the JSON answer to CSV. The CSV column names are: 'actual_date,cod_stop,cod_line,cod_issue,eta,destination_stop' Parameters: Name Type Description Default cod_stops list List of stop codes in CRTM's format (e.g. 8_17491). required Returns: Type Description list Parsed API answers in CSV format. float: Total spent time in seconds. Source code in crtm_poll/crtm_api/stop_times.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def get_stop_times_batch_parsed ( cod_stops , fetch_conf ): \"\"\"Get the stop times for all the bus lines for the given stops parsing the JSON answer to CSV. The CSV column names are: 'actual_date,cod_stop,cod_line,cod_issue,eta,destination_stop' Arguments: cod_stops (list): List of stop codes in CRTM's format (e.g. 8_17491). Returns: list: Parsed API answers in CSV format. float: Total spent time in seconds. \"\"\" json_array , total_time = get_stop_times_batch ( cod_stops , fetch_conf ) csv_array = [] for stop in json_array : try : split_stop = stop . split ( '{' , 1 ) except AttributeError : logger . warning ( \"Empty answer\" ) continue if ( len ( split_stop ) > 1 ): stop = '{' + split_stop [ 1 ] try : stop_json = json . loads ( stop ) except ValueError : logger . warning ( \"json error\" ) continue try : times = stop_json [ 'stopTimes' ][ 'times' ][ 'Time' ] for time in times : selected_fields = [ stop_json [ 'stopTimes' ][ 'actualDate' ], stop_json [ 'stopTimes' ][ 'stop' ][ 'codStop' ], time [ 'line' ][ 'codLine' ], time [ 'codIssue' ], time [ 'time' ], time [ 'destinationStop' ][ 'codStop' ], ] row = ',' . join ( selected_fields ) csv_array . append ( row ) except ( KeyError , TypeError ): logger . warning ( \"Answer without times\" ) continue except Exception as e : logger . warning ( \"Unknown error: \" + str ( e )) continue return csv_array , total_time","title":"get_stop_times_batch_parsed()"},{"location":"reference/crtm_api/stop_times/#crtm_poll.crtm_api.stop_times.run","text":"Async function that generates a aiohttp ClientSession and fetches the given stops. Parameters: Name Type Description Default cod_stops list List of stop codes in CRTM's format (e.g. 8_17491). required fetch_conf dict Dictionary with configuration parameters for fetching the content. required Returns: Type Description list The responses. Source code in crtm_poll/crtm_api/stop_times.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 async def run ( cod_stops , fetch_conf ): \"\"\"Async function that generates a aiohttp ClientSession and fetches the given stops. Arguments: cod_stops (list): List of stop codes in CRTM's format (e.g. 8_17491). fetch_conf (dict): Dictionary with configuration parameters for fetching the content. Returns: list: The responses. \"\"\" tasks = [] # Fetch all responses within one Client session, # keep connection alive for all requests. connector = TCPConnector ( limit = fetch_conf [ 'max_connections' ]) timeout = ClientTimeout ( total = fetch_conf [ 'timeout' ]) async with ClientSession ( connector = connector , timeout = timeout ) as session : for cod_stop in cod_stops : task = asyncio . ensure_future ( fetch ( cod_stop , session , fetch_conf )) tasks . append ( task ) responses = await asyncio . gather ( * tasks ) # you now have all response bodies in this variable return responses","title":"run()"},{"location":"reference/daemon/daemon/","text":"exec_and_write ( func , func_args , output_file , fetch_conf ) Execute a given function with the given args and write the output to the given file preventing collisions with a lock. Parameters: Name Type Description Default func callable Function to execute. required func_args list Arguments to pass to the executed function. required output_file str Path to the file were to append the results. required fetch_conf dict Configuration parameters for fetching the content. required Source code in crtm_poll/daemon/daemon.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def exec_and_write ( func , func_args , output_file , fetch_conf ): \"\"\"Execute a given function with the given args and write the output to the given file preventing collisions with a lock. Arguments: func (callable): Function to execute. func_args (list): Arguments to pass to the executed function. output_file (str): Path to the file were to append the results. fetch_conf (dict): Configuration parameters for fetching the content. \"\"\" result , time = func ( func_args , fetch_conf ) logger . info ( \"Total iteration time: \" + str ( time ) + \"s\" ) with FileLock ( output_file + '.lock' , timeout = 60 ): path_exists = pathlib . Path ( output_file ) . exists () with open ( output_file , 'a+' ) as f : if ( path_exists ): f . write ( ' \\n ' ) f . write ( ' \\n ' . join ( result )) logger . info ( \"Finished process at \" + str ( datetime . now ())) start_daemon ( func , func_args , output_file , interval = 60 , processes = 5 , max_conn_test = None , fetch_conf = {}) Start a daemon that infinitely spawns a given function asynchronously every interval and writes the output to a file. Parameters: Name Type Description Default func callable Function to execute. required func_args list Arguments to pass to the executed function. required output_file str Path to the file were to append the results. required interval int Number of seconds between spawns (the spawning period). 60 processes int Maximum number of simultaneously running spawned processes. 5 max_conn_test list Test different maximum (simultaneous) connections in random order. Pass 4 integer values: start, stop, step and repetition (e.g. list(5, 101, 5, 1) ). None fetch_conf dict Configuration parameters for fetching the content. {} Source code in crtm_poll/daemon/daemon.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def start_daemon ( func , func_args , output_file , interval = 60 , processes = 5 , max_conn_test = None , fetch_conf = {}): \"\"\"Start a daemon that infinitely spawns a given function asynchronously every interval and writes the output to a file. Arguments: func (callable): Function to execute. func_args (list): Arguments to pass to the executed function. output_file (str): Path to the file were to append the results. interval (int): Number of seconds between spawns (the spawning period). processes (int): Maximum number of simultaneously running spawned processes. max_conn_test (list): Test different maximum (simultaneous) connections in random order. Pass 4 integer values: start, stop, step and repetition (e.g. `list(5, 101, 5, 1)`). fetch_conf (dict): Configuration parameters for fetching the content. \"\"\" pool = Pool ( processes = processes ) max_conn_values = None if ( max_conn_test ): if ( len ( max_conn_test ) == 4 ): max_conn_start = max_conn_test [ 0 ] max_conn_stop = max_conn_test [ 1 ] max_conn_step = max_conn_test [ 2 ] max_conn_repeat = max_conn_test [ 3 ] max_conn_values = list ( range ( max_conn_start , max_conn_stop , max_conn_step )) random . shuffle ( max_conn_values ) max_conn_values = list ( itertools . chain . from_iterable ( itertools . repeat ( x , max_conn_repeat ) for x in max_conn_values )) logger . debug ( max_conn_values ) else : sys . exit ( 1 ) while True : if ( max_conn_test ): if ( len ( max_conn_values ) > 0 ): fetch_conf [ 'max_connections' ] = max_conn_values . pop ( 0 ) logger . info ( \"Spawned process at \" + str ( datetime . now ())) pool . apply_async ( exec_and_write , ( func , func_args , output_file , fetch_conf )) if ( max_conn_test ): if ( len ( max_conn_values ) < 1 ): while pool . _cache : time . sleep ( 1 ) logger . info ( \"Finished max_conn_test\" ) pool . close () pool . join () sys . exit ( 0 ) time . sleep ( interval )","title":"daemon.py"},{"location":"reference/daemon/daemon/#crtm_poll.daemon.daemon","text":"","title":"crtm_poll.daemon.daemon"},{"location":"reference/daemon/daemon/#crtm_poll.daemon.daemon.exec_and_write","text":"Execute a given function with the given args and write the output to the given file preventing collisions with a lock. Parameters: Name Type Description Default func callable Function to execute. required func_args list Arguments to pass to the executed function. required output_file str Path to the file were to append the results. required fetch_conf dict Configuration parameters for fetching the content. required Source code in crtm_poll/daemon/daemon.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def exec_and_write ( func , func_args , output_file , fetch_conf ): \"\"\"Execute a given function with the given args and write the output to the given file preventing collisions with a lock. Arguments: func (callable): Function to execute. func_args (list): Arguments to pass to the executed function. output_file (str): Path to the file were to append the results. fetch_conf (dict): Configuration parameters for fetching the content. \"\"\" result , time = func ( func_args , fetch_conf ) logger . info ( \"Total iteration time: \" + str ( time ) + \"s\" ) with FileLock ( output_file + '.lock' , timeout = 60 ): path_exists = pathlib . Path ( output_file ) . exists () with open ( output_file , 'a+' ) as f : if ( path_exists ): f . write ( ' \\n ' ) f . write ( ' \\n ' . join ( result )) logger . info ( \"Finished process at \" + str ( datetime . now ()))","title":"exec_and_write()"},{"location":"reference/daemon/daemon/#crtm_poll.daemon.daemon.start_daemon","text":"Start a daemon that infinitely spawns a given function asynchronously every interval and writes the output to a file. Parameters: Name Type Description Default func callable Function to execute. required func_args list Arguments to pass to the executed function. required output_file str Path to the file were to append the results. required interval int Number of seconds between spawns (the spawning period). 60 processes int Maximum number of simultaneously running spawned processes. 5 max_conn_test list Test different maximum (simultaneous) connections in random order. Pass 4 integer values: start, stop, step and repetition (e.g. list(5, 101, 5, 1) ). None fetch_conf dict Configuration parameters for fetching the content. {} Source code in crtm_poll/daemon/daemon.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def start_daemon ( func , func_args , output_file , interval = 60 , processes = 5 , max_conn_test = None , fetch_conf = {}): \"\"\"Start a daemon that infinitely spawns a given function asynchronously every interval and writes the output to a file. Arguments: func (callable): Function to execute. func_args (list): Arguments to pass to the executed function. output_file (str): Path to the file were to append the results. interval (int): Number of seconds between spawns (the spawning period). processes (int): Maximum number of simultaneously running spawned processes. max_conn_test (list): Test different maximum (simultaneous) connections in random order. Pass 4 integer values: start, stop, step and repetition (e.g. `list(5, 101, 5, 1)`). fetch_conf (dict): Configuration parameters for fetching the content. \"\"\" pool = Pool ( processes = processes ) max_conn_values = None if ( max_conn_test ): if ( len ( max_conn_test ) == 4 ): max_conn_start = max_conn_test [ 0 ] max_conn_stop = max_conn_test [ 1 ] max_conn_step = max_conn_test [ 2 ] max_conn_repeat = max_conn_test [ 3 ] max_conn_values = list ( range ( max_conn_start , max_conn_stop , max_conn_step )) random . shuffle ( max_conn_values ) max_conn_values = list ( itertools . chain . from_iterable ( itertools . repeat ( x , max_conn_repeat ) for x in max_conn_values )) logger . debug ( max_conn_values ) else : sys . exit ( 1 ) while True : if ( max_conn_test ): if ( len ( max_conn_values ) > 0 ): fetch_conf [ 'max_connections' ] = max_conn_values . pop ( 0 ) logger . info ( \"Spawned process at \" + str ( datetime . now ())) pool . apply_async ( exec_and_write , ( func , func_args , output_file , fetch_conf )) if ( max_conn_test ): if ( len ( max_conn_values ) < 1 ): while pool . _cache : time . sleep ( 1 ) logger . info ( \"Finished max_conn_test\" ) pool . close () pool . join () sys . exit ( 0 ) time . sleep ( interval )","title":"start_daemon()"}]}